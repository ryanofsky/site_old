Index: tree.c
===================================================================
--- tree.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ tree.c	(.../trunk/gcc)	(revision 38)
@@ -4276,11 +4276,10 @@
   return build_pointer_type_for_mode (to_type, ptr_mode, false);
 }
 
-/* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */
 
 tree
-build_reference_type_for_mode (tree to_type, enum machine_mode mode,
-			       bool can_alias_all)
+build_rval_reference_type_for_mode (tree to_type, enum machine_mode mode,
+                                    bool can_alias_all, bool rval)
 {
   tree t;
 
@@ -4299,7 +4298,8 @@
   /* First, if we already have a type for pointers to TO_TYPE and it's
      the proper mode, use it.  */
   for (t = TYPE_REFERENCE_TO (to_type); t; t = TYPE_NEXT_REF_TO (t))
-    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)
+    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all
+        && TYPE_REF_IS_RVALUE(t) == rval)
       return t;
 
   t = make_node (REFERENCE_TYPE);
@@ -4307,6 +4307,7 @@
   TREE_TYPE (t) = to_type;
   TYPE_MODE (t) = mode;
   TYPE_REF_CAN_ALIAS_ALL (t) = can_alias_all;
+  TYPE_REF_IS_RVALUE(t) = rval;
   TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (to_type);
   TYPE_REFERENCE_TO (to_type) = t;
 
@@ -4315,16 +4316,35 @@
   return t;
 }
 
+/* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */
 
+tree
+build_reference_type_for_mode (tree to_type, enum machine_mode mode,
+                                    bool can_alias_all)
+{
+  return build_rval_reference_type_for_mode (to_type, mode,
+                                             can_alias_all,
+                                             false);
+}
+
 /* Build the node for the type of references-to-TO_TYPE by default
    in ptr_mode.  */
 
 tree
+build_rval_reference_type (tree to_type, bool rval)
+{
+  return build_rval_reference_type_for_mode (to_type, ptr_mode, false, rval);
+}
+
+/* Build the node for lvalue references. */
+
+tree
 build_reference_type (tree to_type)
 {
   return build_reference_type_for_mode (to_type, ptr_mode, false);
 }
 
+
 /* Build a type that is compatible with t but has no cv quals anywhere
    in its type, thus
 
Index: tree.h
===================================================================
--- tree.h	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ tree.h	(.../trunk/gcc)	(revision 38)
@@ -351,6 +351,8 @@
 	   ..._DECL
        CALL_FROM_THUNK_P in
            CALL_EXPR
+       TYPE_REF_IS_RVALUE in
+         REFERENCE_TYPE
 
    side_effects_flag:
 
@@ -1003,6 +1005,10 @@
    thunked-to function.  */
 #define CALL_FROM_THUNK_P(NODE) ((NODE)->common.protected_flag)
 
+/* In a REFERENCE_TYPE, means that reference is an rvalue reference */
+#define TYPE_REF_IS_RVALUE(NODE) \
+  (REFERENCE_TYPE_CHECK (NODE)->common.protected_flag)
+
 /* In a type, nonzero means that all objects of the type are guaranteed by the
    language or front-end to be properly aligned, so we can indicate that a MEM
    of this type is aligned at least to the alignment of the type, even if it
@@ -2893,7 +2899,10 @@
 extern void fixup_unsigned_type (tree);
 extern tree build_pointer_type_for_mode (tree, enum machine_mode, bool);
 extern tree build_pointer_type (tree);
+extern tree build_rval_reference_type_for_mode
+  (tree, enum machine_mode, bool, bool);
 extern tree build_reference_type_for_mode (tree, enum machine_mode, bool);
+extern tree build_rval_reference_type (tree, bool);
 extern tree build_reference_type (tree);
 extern tree build_vector_type_for_mode (tree, enum machine_mode);
 extern tree build_vector_type (tree innertype, int nunits);
Index: testsuite/g++.dg/rref/overload.py
===================================================================
--- testsuite/g++.dg/rref/overload.py	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/overload.py	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,155 @@
+import sys
+import StringIO
+
+# template for output file
+template = """\
+// { dg-do link }
+// Generated by overload.py
+
+struct S{};
+
+S l;                             // lvalue (l)
+S const cl = l;                  // const lvalue (cl)
+S r() { return l; }              // rvalue (r)
+S const cr() { return l; }       // const rvalue (cr)
+S & nl = l;                      // named lvalue reference (nl)
+S const & ncl = l;               // named const lvalue reference (ncl)
+S && nr = l;                     // named rvalue reference (nr)
+S const && ncr = l;              // named const rvalue reference (ncr)
+S & ul() { return l; }           // unnamed lvalue reference (ul)
+S const & ucl() { return l; }    // unnamed const lvalue reference (ucl)
+S && ur() { return l; }          // unnamed rvalue reference (ur)
+S const && ucr() { return l; }   // unnamed const rvalue reference (ucr)
+
+%(funcs)s
+int main()
+{
+%(calls)s
+  return 0;
+}
+"""
+
+# parameters to overload on
+params = ('S&', 'const S&', 'S&&', 'const S&&')
+
+# arguments to test overloads on in (function prefix, argument) tuples
+args = (
+  ('l', 'l'),
+  ('cl', 'cl'),
+  ('r', 'r()'),
+  ('cr', 'cr()'),
+  ('nl', 'nl'),
+  ('ncl', 'ncl'),
+  ('nr', 'nr'),
+  ('ncr', 'ncr'),
+  ('ul', 'ul()'),
+  ('ucl', 'ucl()'),
+  ('ur', 'ur()'),
+  ('ucr', 'ucr()'),
+)
+
+# everybody get out your sharpened number 2 pencils
+answers = {
+  'l':  ( 3, #0001
+          2, #0010
+          2, #0011
+          1, #0100
+          1, #0101
+          1, #0110
+          1, #0111
+          0, #1000
+          0, #1001
+          0, #1010
+          0, #1011
+          0, #1100
+          0, #1101
+          0, #1110
+          0, #1111
+        ),
+  'cl': ( 3, #0001
+          None, #0010
+          3, #0011
+          1, #0100
+          1, #0101
+          1, #0110
+          1, #0111
+          None, #1000
+          3, #1001
+          None, #1010
+          3, #1011
+          1, #1100
+          1, #1101
+          1, #1110
+          1, #1111
+        ),
+   'r': (3, #0001
+          2, #0010
+          2, #0011
+          1, #0100
+          3, #0101
+          2, #0110
+          2, #0111
+          None, #1000
+          3, #1001
+          2, #1010
+          2, #1011
+          1, #1100
+          3, #1101
+          2, #1110
+          2, #1111
+        ),
+  'cr': ( 3, #0001
+          None, #0010
+          3, #0011
+          1, #0100
+          3, #0101
+          1, #0110
+          3, #0111
+          None, #1000
+          3, #1001
+          None, #1010
+          3, #1011
+          1, #1100
+          3, #1101
+          1, #1110
+          3, #1111
+        )}
+answers['nl'] = answers['l']
+answers['ncl'] = answers['cl']
+answers['nr'] = answers['l']
+answers['ncr'] = answers['cl']
+answers['ul'] = answers['l']
+answers['ucl'] = answers['cl']
+answers['ur'] = answers['r']
+answers['ucr'] = answers['cr']
+
+funcs = StringIO.StringIO()
+calls = StringIO.StringIO()
+
+for func_prefix, arg in args:
+  for param_set in range(1, 1<<len(params)):
+    answer = answers[func_prefix][param_set-1]
+    if answer is None:
+      continue
+
+    func_name = []
+    func_params = []
+    for param_idx in range(len(params)):
+      if param_set & (1 << (len(params)-param_idx-1)):
+        func_params.append(param_idx)
+        func_name.append('1')
+      else:
+        func_name.append('0')
+
+    func_name = func_prefix + ''.join(func_name)
+
+    for param_idx in func_params:
+      body = param_idx == answer and ' {}' or ';'
+      funcs.write('void %s(%s)%s\n' % (func_name, params[param_idx], body))
+    funcs.write('\n')
+
+    calls.write('  %s(%s);\n' % (func_name, arg))
+
+sys.stdout.write(template % { 'funcs': funcs.getvalue(),
+                              'calls': calls.getvalue()})
+
Index: testsuite/g++.dg/rref/implicit-copy.C
===================================================================
--- testsuite/g++.dg/rref/implicit-copy.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/implicit-copy.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,14 @@
+struct S
+{
+  S();
+private:
+  S(S const &&);
+  S & operator=(S const &&);
+};
+
+void f()
+{
+  S a;
+  S b(a);
+  a = b;
+}
Index: testsuite/g++.dg/rref/collapse.C
===================================================================
--- testsuite/g++.dg/rref/collapse.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/collapse.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,37 @@
+template<typename T, typename U> struct same_type;
+template<typename T> struct same_type<T, T> {};
+
+typedef int & lref;
+typedef int const & clref;
+typedef int && rref;
+typedef int const && crref;
+
+template<typename T>
+struct S
+{
+  typedef T & lref;
+  typedef T const & clref;
+  typedef T && rref;
+  typedef T const && crref;
+};
+
+void f()
+{
+  same_type<lref &, int &>();
+  same_type<lref &&, int &>();
+  same_type<rref &, int &>();
+  same_type<rref &&, int &&>();
+
+  same_type<rref const &, int const &>();
+  same_type<crref volatile &&, int volatile const &&>();
+  same_type<clref const &&, int const &>();
+
+  same_type<S<int &>::lref &, int &>();
+  same_type<S<int &&>::lref &&, int &>();
+  same_type<S<int &>::rref &, int &>();
+  same_type<S<int &&>::rref &&, int &&>();
+
+  same_type<S<int const &>::rref, int const &>();
+  same_type<S<int volatile &&>::crref, int volatile const &&>();
+  same_type<S<int const &&>::clref, int const &>();
+}
Index: testsuite/g++.dg/rref/named.C
===================================================================
--- testsuite/g++.dg/rref/named.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/named.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,34 @@
+// { dg-do link }
+
+struct S {};
+struct T
+{
+  T(S && s_) : s(s_) {}
+  S && get() { return s; }
+  operator S&&() { return s; }
+  S && s;
+};
+
+void named(S const &) {}
+void named(S&&);
+
+void unnamed(S const &);
+void unnamed(S&&) {}
+
+void f(S && p)
+{
+  S && s(p);
+  T t(s);
+
+  named(s);                          // variable reference
+  named(p);                          // parameter reference
+  named(t.s);                        // class member access
+
+  unnamed(t.get());                  // function return
+  unnamed(t);                        // implicit conversion
+  unnamed(static_cast<S&&>(s));      // cast to rvalue
+}
+
+int main()
+{
+}
Index: testsuite/g++.dg/rref/overload-func.C
===================================================================
--- testsuite/g++.dg/rref/overload-func.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/overload-func.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,16 @@
+// { dg-do link }
+
+struct S{};
+S & lvalue() { return *static_cast<S*>(0); }
+S rvalue() { return S(); }
+
+void f(const S&) {}
+void f(S&&);
+void g(const S&);
+void g(S&&) {}
+
+int main()
+{
+  f(lvalue());
+  g(rvalue());
+}
Index: testsuite/g++.dg/rref/cast-bug.C
===================================================================
--- testsuite/g++.dg/rref/cast-bug.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/cast-bug.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,13 @@
+struct S
+{
+  S();
+  S(S &&);
+private:
+  S(S &);
+};
+
+S f()
+{
+  S s;
+  return static_cast<S&&>(s);
+}
Index: testsuite/g++.dg/rref/deduce.C
===================================================================
--- testsuite/g++.dg/rref/deduce.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/deduce.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,35 @@
+template<typename T, typename U> struct same_type;
+template<typename T> struct same_type<T, T> {};
+
+int lval_int;
+int rval_int();
+int const lval_const_int=0;
+int const rval_const_int();
+
+template <typename T> void deduce_lval_int(T && t)
+{
+  same_type<T, int &>();
+}
+
+template <typename T> void deduce_rval_int(T && t)
+{
+  same_type<T, int>();
+}
+
+template <typename T> void deduce_lval_const_int(T && t)
+{
+  same_type<T, const int &>();
+}
+
+template <typename T> void deduce_rval_const_int(T && t)
+{
+  same_type<T, const int>();
+}
+
+void f()
+{
+  deduce_lval_int(lval_int);
+  deduce_rval_int(rval_int());
+  deduce_lval_const_int(lval_const_int);
+  deduce_rval_const_int(rval_const_int());
+}
Index: testsuite/g++.dg/rref/overload.C
===================================================================
--- testsuite/g++.dg/rref/overload.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/overload.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,702 @@
+// { dg-do link }
+// Generated by overload.py
+
+struct S{};
+
+S l;                             // lvalue (l)
+S const cl = l;                  // const lvalue (cl)
+S r() { return l; }              // rvalue (r)
+S const cr() { return l; }       // const rvalue (cr)
+S & nl = l;                      // named lvalue reference (nl)
+S const & ncl = l;               // named const lvalue reference (ncl)
+S && nr = l;                     // named rvalue reference (nr)
+S const && ncr = l;              // named const rvalue reference (ncr)
+S & ul() { return l; }           // unnamed lvalue reference (ul)
+S const & ucl() { return l; }    // unnamed const lvalue reference (ucl)
+S && ur() { return l; }          // unnamed rvalue reference (ur)
+S const && ucr() { return l; }   // unnamed const rvalue reference (ucr)
+
+void l0001(const S&&) {}
+
+void l0010(S&&) {}
+
+void l0011(S&&) {}
+void l0011(const S&&);
+
+void l0100(const S&) {}
+
+void l0101(const S&) {}
+void l0101(const S&&);
+
+void l0110(const S&) {}
+void l0110(S&&);
+
+void l0111(const S&) {}
+void l0111(S&&);
+void l0111(const S&&);
+
+void l1000(S&) {}
+
+void l1001(S&) {}
+void l1001(const S&&);
+
+void l1010(S&) {}
+void l1010(S&&);
+
+void l1011(S&) {}
+void l1011(S&&);
+void l1011(const S&&);
+
+void l1100(S&) {}
+void l1100(const S&);
+
+void l1101(S&) {}
+void l1101(const S&);
+void l1101(const S&&);
+
+void l1110(S&) {}
+void l1110(const S&);
+void l1110(S&&);
+
+void l1111(S&) {}
+void l1111(const S&);
+void l1111(S&&);
+void l1111(const S&&);
+
+void cl0001(const S&&) {}
+
+void cl0011(S&&);
+void cl0011(const S&&) {}
+
+void cl0100(const S&) {}
+
+void cl0101(const S&) {}
+void cl0101(const S&&);
+
+void cl0110(const S&) {}
+void cl0110(S&&);
+
+void cl0111(const S&) {}
+void cl0111(S&&);
+void cl0111(const S&&);
+
+void cl1001(S&);
+void cl1001(const S&&) {}
+
+void cl1011(S&);
+void cl1011(S&&);
+void cl1011(const S&&) {}
+
+void cl1100(S&);
+void cl1100(const S&) {}
+
+void cl1101(S&);
+void cl1101(const S&) {}
+void cl1101(const S&&);
+
+void cl1110(S&);
+void cl1110(const S&) {}
+void cl1110(S&&);
+
+void cl1111(S&);
+void cl1111(const S&) {}
+void cl1111(S&&);
+void cl1111(const S&&);
+
+void r0001(const S&&) {}
+
+void r0010(S&&) {}
+
+void r0011(S&&) {}
+void r0011(const S&&);
+
+void r0100(const S&) {}
+
+void r0101(const S&);
+void r0101(const S&&) {}
+
+void r0110(const S&);
+void r0110(S&&) {}
+
+void r0111(const S&);
+void r0111(S&&) {}
+void r0111(const S&&);
+
+void r1001(S&);
+void r1001(const S&&) {}
+
+void r1010(S&);
+void r1010(S&&) {}
+
+void r1011(S&);
+void r1011(S&&) {}
+void r1011(const S&&);
+
+void r1100(S&);
+void r1100(const S&) {}
+
+void r1101(S&);
+void r1101(const S&);
+void r1101(const S&&) {}
+
+void r1110(S&);
+void r1110(const S&);
+void r1110(S&&) {}
+
+void r1111(S&);
+void r1111(const S&);
+void r1111(S&&) {}
+void r1111(const S&&);
+
+void cr0001(const S&&) {}
+
+void cr0011(S&&);
+void cr0011(const S&&) {}
+
+void cr0100(const S&) {}
+
+void cr0101(const S&);
+void cr0101(const S&&) {}
+
+void cr0110(const S&) {}
+void cr0110(S&&);
+
+void cr0111(const S&);
+void cr0111(S&&);
+void cr0111(const S&&) {}
+
+void cr1001(S&);
+void cr1001(const S&&) {}
+
+void cr1011(S&);
+void cr1011(S&&);
+void cr1011(const S&&) {}
+
+void cr1100(S&);
+void cr1100(const S&) {}
+
+void cr1101(S&);
+void cr1101(const S&);
+void cr1101(const S&&) {}
+
+void cr1110(S&);
+void cr1110(const S&) {}
+void cr1110(S&&);
+
+void cr1111(S&);
+void cr1111(const S&);
+void cr1111(S&&);
+void cr1111(const S&&) {}
+
+void nl0001(const S&&) {}
+
+void nl0010(S&&) {}
+
+void nl0011(S&&) {}
+void nl0011(const S&&);
+
+void nl0100(const S&) {}
+
+void nl0101(const S&) {}
+void nl0101(const S&&);
+
+void nl0110(const S&) {}
+void nl0110(S&&);
+
+void nl0111(const S&) {}
+void nl0111(S&&);
+void nl0111(const S&&);
+
+void nl1000(S&) {}
+
+void nl1001(S&) {}
+void nl1001(const S&&);
+
+void nl1010(S&) {}
+void nl1010(S&&);
+
+void nl1011(S&) {}
+void nl1011(S&&);
+void nl1011(const S&&);
+
+void nl1100(S&) {}
+void nl1100(const S&);
+
+void nl1101(S&) {}
+void nl1101(const S&);
+void nl1101(const S&&);
+
+void nl1110(S&) {}
+void nl1110(const S&);
+void nl1110(S&&);
+
+void nl1111(S&) {}
+void nl1111(const S&);
+void nl1111(S&&);
+void nl1111(const S&&);
+
+void ncl0001(const S&&) {}
+
+void ncl0011(S&&);
+void ncl0011(const S&&) {}
+
+void ncl0100(const S&) {}
+
+void ncl0101(const S&) {}
+void ncl0101(const S&&);
+
+void ncl0110(const S&) {}
+void ncl0110(S&&);
+
+void ncl0111(const S&) {}
+void ncl0111(S&&);
+void ncl0111(const S&&);
+
+void ncl1001(S&);
+void ncl1001(const S&&) {}
+
+void ncl1011(S&);
+void ncl1011(S&&);
+void ncl1011(const S&&) {}
+
+void ncl1100(S&);
+void ncl1100(const S&) {}
+
+void ncl1101(S&);
+void ncl1101(const S&) {}
+void ncl1101(const S&&);
+
+void ncl1110(S&);
+void ncl1110(const S&) {}
+void ncl1110(S&&);
+
+void ncl1111(S&);
+void ncl1111(const S&) {}
+void ncl1111(S&&);
+void ncl1111(const S&&);
+
+void nr0001(const S&&) {}
+
+void nr0010(S&&) {}
+
+void nr0011(S&&) {}
+void nr0011(const S&&);
+
+void nr0100(const S&) {}
+
+void nr0101(const S&) {}
+void nr0101(const S&&);
+
+void nr0110(const S&) {}
+void nr0110(S&&);
+
+void nr0111(const S&) {}
+void nr0111(S&&);
+void nr0111(const S&&);
+
+void nr1000(S&) {}
+
+void nr1001(S&) {}
+void nr1001(const S&&);
+
+void nr1010(S&) {}
+void nr1010(S&&);
+
+void nr1011(S&) {}
+void nr1011(S&&);
+void nr1011(const S&&);
+
+void nr1100(S&) {}
+void nr1100(const S&);
+
+void nr1101(S&) {}
+void nr1101(const S&);
+void nr1101(const S&&);
+
+void nr1110(S&) {}
+void nr1110(const S&);
+void nr1110(S&&);
+
+void nr1111(S&) {}
+void nr1111(const S&);
+void nr1111(S&&);
+void nr1111(const S&&);
+
+void ncr0001(const S&&) {}
+
+void ncr0011(S&&);
+void ncr0011(const S&&) {}
+
+void ncr0100(const S&) {}
+
+void ncr0101(const S&) {}
+void ncr0101(const S&&);
+
+void ncr0110(const S&) {}
+void ncr0110(S&&);
+
+void ncr0111(const S&) {}
+void ncr0111(S&&);
+void ncr0111(const S&&);
+
+void ncr1001(S&);
+void ncr1001(const S&&) {}
+
+void ncr1011(S&);
+void ncr1011(S&&);
+void ncr1011(const S&&) {}
+
+void ncr1100(S&);
+void ncr1100(const S&) {}
+
+void ncr1101(S&);
+void ncr1101(const S&) {}
+void ncr1101(const S&&);
+
+void ncr1110(S&);
+void ncr1110(const S&) {}
+void ncr1110(S&&);
+
+void ncr1111(S&);
+void ncr1111(const S&) {}
+void ncr1111(S&&);
+void ncr1111(const S&&);
+
+void ul0001(const S&&) {}
+
+void ul0010(S&&) {}
+
+void ul0011(S&&) {}
+void ul0011(const S&&);
+
+void ul0100(const S&) {}
+
+void ul0101(const S&) {}
+void ul0101(const S&&);
+
+void ul0110(const S&) {}
+void ul0110(S&&);
+
+void ul0111(const S&) {}
+void ul0111(S&&);
+void ul0111(const S&&);
+
+void ul1000(S&) {}
+
+void ul1001(S&) {}
+void ul1001(const S&&);
+
+void ul1010(S&) {}
+void ul1010(S&&);
+
+void ul1011(S&) {}
+void ul1011(S&&);
+void ul1011(const S&&);
+
+void ul1100(S&) {}
+void ul1100(const S&);
+
+void ul1101(S&) {}
+void ul1101(const S&);
+void ul1101(const S&&);
+
+void ul1110(S&) {}
+void ul1110(const S&);
+void ul1110(S&&);
+
+void ul1111(S&) {}
+void ul1111(const S&);
+void ul1111(S&&);
+void ul1111(const S&&);
+
+void ucl0001(const S&&) {}
+
+void ucl0011(S&&);
+void ucl0011(const S&&) {}
+
+void ucl0100(const S&) {}
+
+void ucl0101(const S&) {}
+void ucl0101(const S&&);
+
+void ucl0110(const S&) {}
+void ucl0110(S&&);
+
+void ucl0111(const S&) {}
+void ucl0111(S&&);
+void ucl0111(const S&&);
+
+void ucl1001(S&);
+void ucl1001(const S&&) {}
+
+void ucl1011(S&);
+void ucl1011(S&&);
+void ucl1011(const S&&) {}
+
+void ucl1100(S&);
+void ucl1100(const S&) {}
+
+void ucl1101(S&);
+void ucl1101(const S&) {}
+void ucl1101(const S&&);
+
+void ucl1110(S&);
+void ucl1110(const S&) {}
+void ucl1110(S&&);
+
+void ucl1111(S&);
+void ucl1111(const S&) {}
+void ucl1111(S&&);
+void ucl1111(const S&&);
+
+void ur0001(const S&&) {}
+
+void ur0010(S&&) {}
+
+void ur0011(S&&) {}
+void ur0011(const S&&);
+
+void ur0100(const S&) {}
+
+void ur0101(const S&);
+void ur0101(const S&&) {}
+
+void ur0110(const S&);
+void ur0110(S&&) {}
+
+void ur0111(const S&);
+void ur0111(S&&) {}
+void ur0111(const S&&);
+
+void ur1001(S&);
+void ur1001(const S&&) {}
+
+void ur1010(S&);
+void ur1010(S&&) {}
+
+void ur1011(S&);
+void ur1011(S&&) {}
+void ur1011(const S&&);
+
+void ur1100(S&);
+void ur1100(const S&) {}
+
+void ur1101(S&);
+void ur1101(const S&);
+void ur1101(const S&&) {}
+
+void ur1110(S&);
+void ur1110(const S&);
+void ur1110(S&&) {}
+
+void ur1111(S&);
+void ur1111(const S&);
+void ur1111(S&&) {}
+void ur1111(const S&&);
+
+void ucr0001(const S&&) {}
+
+void ucr0011(S&&);
+void ucr0011(const S&&) {}
+
+void ucr0100(const S&) {}
+
+void ucr0101(const S&);
+void ucr0101(const S&&) {}
+
+void ucr0110(const S&) {}
+void ucr0110(S&&);
+
+void ucr0111(const S&);
+void ucr0111(S&&);
+void ucr0111(const S&&) {}
+
+void ucr1001(S&);
+void ucr1001(const S&&) {}
+
+void ucr1011(S&);
+void ucr1011(S&&);
+void ucr1011(const S&&) {}
+
+void ucr1100(S&);
+void ucr1100(const S&) {}
+
+void ucr1101(S&);
+void ucr1101(const S&);
+void ucr1101(const S&&) {}
+
+void ucr1110(S&);
+void ucr1110(const S&) {}
+void ucr1110(S&&);
+
+void ucr1111(S&);
+void ucr1111(const S&);
+void ucr1111(S&&);
+void ucr1111(const S&&) {}
+
+
+int main()
+{
+  l0001(l);
+  l0010(l);
+  l0011(l);
+  l0100(l);
+  l0101(l);
+  l0110(l);
+  l0111(l);
+  l1000(l);
+  l1001(l);
+  l1010(l);
+  l1011(l);
+  l1100(l);
+  l1101(l);
+  l1110(l);
+  l1111(l);
+  cl0001(cl);
+  cl0011(cl);
+  cl0100(cl);
+  cl0101(cl);
+  cl0110(cl);
+  cl0111(cl);
+  cl1001(cl);
+  cl1011(cl);
+  cl1100(cl);
+  cl1101(cl);
+  cl1110(cl);
+  cl1111(cl);
+  r0001(r());
+  r0010(r());
+  r0011(r());
+  r0100(r());
+  r0101(r());
+  r0110(r());
+  r0111(r());
+  r1001(r());
+  r1010(r());
+  r1011(r());
+  r1100(r());
+  r1101(r());
+  r1110(r());
+  r1111(r());
+  cr0001(cr());
+  cr0011(cr());
+  cr0100(cr());
+  cr0101(cr());
+  cr0110(cr());
+  cr0111(cr());
+  cr1001(cr());
+  cr1011(cr());
+  cr1100(cr());
+  cr1101(cr());
+  cr1110(cr());
+  cr1111(cr());
+  nl0001(nl);
+  nl0010(nl);
+  nl0011(nl);
+  nl0100(nl);
+  nl0101(nl);
+  nl0110(nl);
+  nl0111(nl);
+  nl1000(nl);
+  nl1001(nl);
+  nl1010(nl);
+  nl1011(nl);
+  nl1100(nl);
+  nl1101(nl);
+  nl1110(nl);
+  nl1111(nl);
+  ncl0001(ncl);
+  ncl0011(ncl);
+  ncl0100(ncl);
+  ncl0101(ncl);
+  ncl0110(ncl);
+  ncl0111(ncl);
+  ncl1001(ncl);
+  ncl1011(ncl);
+  ncl1100(ncl);
+  ncl1101(ncl);
+  ncl1110(ncl);
+  ncl1111(ncl);
+  nr0001(nr);
+  nr0010(nr);
+  nr0011(nr);
+  nr0100(nr);
+  nr0101(nr);
+  nr0110(nr);
+  nr0111(nr);
+  nr1000(nr);
+  nr1001(nr);
+  nr1010(nr);
+  nr1011(nr);
+  nr1100(nr);
+  nr1101(nr);
+  nr1110(nr);
+  nr1111(nr);
+  ncr0001(ncr);
+  ncr0011(ncr);
+  ncr0100(ncr);
+  ncr0101(ncr);
+  ncr0110(ncr);
+  ncr0111(ncr);
+  ncr1001(ncr);
+  ncr1011(ncr);
+  ncr1100(ncr);
+  ncr1101(ncr);
+  ncr1110(ncr);
+  ncr1111(ncr);
+  ul0001(ul());
+  ul0010(ul());
+  ul0011(ul());
+  ul0100(ul());
+  ul0101(ul());
+  ul0110(ul());
+  ul0111(ul());
+  ul1000(ul());
+  ul1001(ul());
+  ul1010(ul());
+  ul1011(ul());
+  ul1100(ul());
+  ul1101(ul());
+  ul1110(ul());
+  ul1111(ul());
+  ucl0001(ucl());
+  ucl0011(ucl());
+  ucl0100(ucl());
+  ucl0101(ucl());
+  ucl0110(ucl());
+  ucl0111(ucl());
+  ucl1001(ucl());
+  ucl1011(ucl());
+  ucl1100(ucl());
+  ucl1101(ucl());
+  ucl1110(ucl());
+  ucl1111(ucl());
+  ur0001(ur());
+  ur0010(ur());
+  ur0011(ur());
+  ur0100(ur());
+  ur0101(ur());
+  ur0110(ur());
+  ur0111(ur());
+  ur1001(ur());
+  ur1010(ur());
+  ur1011(ur());
+  ur1100(ur());
+  ur1101(ur());
+  ur1110(ur());
+  ur1111(ur());
+  ucr0001(ucr());
+  ucr0011(ucr());
+  ucr0100(ucr());
+  ucr0101(ucr());
+  ucr0110(ucr());
+  ucr0111(ucr());
+  ucr1001(ucr());
+  ucr1011(ucr());
+  ucr1100(ucr());
+  ucr1101(ucr());
+  ucr1110(ucr());
+  ucr1111(ucr());
+
+  return 0;
+}
Index: testsuite/g++.dg/rref/overload-conv-1.C
===================================================================
--- testsuite/g++.dg/rref/overload-conv-1.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/overload-conv-1.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,28 @@
+// { dg-do link }
+
+struct S {};
+
+struct T
+{
+  operator S() { return S(); }
+};
+
+struct U
+{
+  operator S&() { return *static_cast<S*>(0); }
+};
+
+void f(const S&);
+void f(S&&) {}
+
+void g(const S&) {}
+void g(S&&);
+
+int main()
+{
+  T t;
+  f(t);
+
+  U u;
+  g(u);
+}
Index: testsuite/g++.dg/rref/bind.C
===================================================================
--- testsuite/g++.dg/rref/bind.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/bind.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,7 @@
+struct S{};
+void f(S&&);
+
+int main()
+{
+  f(S());
+}
Index: testsuite/g++.dg/rref/overload-conv-2.C
===================================================================
--- testsuite/g++.dg/rref/overload-conv-2.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/overload-conv-2.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,16 @@
+// { dg-do link }
+
+struct T {};
+struct S
+{
+  S(T const &) {}
+};
+
+void f(const S&);
+void f(S&&) {}
+
+int main()
+{
+  T t;
+  f(t);
+}
Index: testsuite/g++.dg/rref/collapse-bug.C
===================================================================
--- testsuite/g++.dg/rref/collapse-bug.C	(.../vendor/gcc/4.0.0/gcc)	(revision 0)
+++ testsuite/g++.dg/rref/collapse-bug.C	(.../trunk/gcc)	(revision 38)
@@ -0,0 +1,15 @@
+template<typename T, typename U> struct same_type;
+template<typename T> struct same_type<T, T> {};
+
+template <typename T>
+struct S
+{
+  typedef T const (&type)();
+};
+
+void f()
+{
+  // initial implementation didn't ignore const qualifier on
+  // reference, resulting in a typedef of 'const int& (&)()'
+  same_type<S<int &>::type, int&(&)()>();
+}
Index: cp/typeck.c
===================================================================
--- cp/typeck.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/typeck.c	(.../trunk/gcc)	(revision 38)
@@ -1029,8 +1029,12 @@
 	return false;
       break;
 
+    case REFERENCE_TYPE:
+      if (TYPE_REF_IS_RVALUE(t1) != TYPE_REF_IS_RVALUE(t2))
+        return false;
+      /* fall through to checks for pointer types */
+
     case POINTER_TYPE:
-    case REFERENCE_TYPE:
       if (TYPE_MODE (t1) != TYPE_MODE (t2)
 	  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2)
 	  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))
Index: cp/decl.c
===================================================================
--- cp/decl.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/decl.c	(.../trunk/gcc)	(revision 38)
@@ -6880,7 +6880,9 @@
   type_quals |= cp_type_quals (type);
   type = cp_build_qualified_type_real
     (type, type_quals, ((typedef_decl && !DECL_ARTIFICIAL (typedef_decl)
- 			 ? tf_ignore_bad_quals : 0) | tf_error | tf_warning));
+                         ? tf_ignore_bad_quals : 0) | tf_error | tf_warning),
+     declarator && declarator->kind == cdk_reference);
+
   /* We might have ignored or rejected some of the qualifiers.  */
   type_quals = cp_type_quals (type);
 
@@ -7246,15 +7248,15 @@
 	case cdk_pointer:
 	case cdk_reference:
 	case cdk_ptrmem:
-	  /* Filter out pointers-to-references and references-to-references.
+	  /* Filter out pointers-to-references.
 	     We can get these if a TYPE_DECL is used.  */
-
 	  if (TREE_CODE (type) == REFERENCE_TYPE)
 	    {
-	      error (declarator->kind == cdk_reference
-		     ? "cannot declare reference to %q#T"
-		     : "cannot declare pointer to %q#T", type);
-	      type = TREE_TYPE (type);
+	      if (declarator->kind != cdk_reference)
+		{
+		  error ("cannot declare pointer to %q#T", type);
+		  type = TREE_TYPE (type);
+		}
 	    }
 	  else if (VOID_TYPE_P (type))
 	    {
@@ -7290,7 +7292,27 @@
 	  if (declarator->kind == cdk_reference)
 	    {
 	      if (!VOID_TYPE_P (type))
-		type = build_reference_type (type);
+                type = build_rval_reference_type
+                       ((TREE_CODE (type) == REFERENCE_TYPE
+                         ? TREE_TYPE (type) : type),
+                        (declarator->u.pointer.rvalue_ref
+                         && (TREE_CODE(type) != REFERENCE_TYPE
+                             || TYPE_REF_IS_RVALUE (type))));
+
+              /* Disallow direct reference to reference declarations,
+                 Reference to reference declarations are only allowed
+                 indirectly through typedefs or template type arguments.
+                 Example:
+
+                   void foo(int & &);      // invalid ref-to-ref decl
+
+                   typedef int & int_ref;
+                   void foo(int_ref &);    // valid ref-to-ref decl
+              */
+              if (declarator->declarator &&
+                  declarator->declarator->kind == cdk_reference)
+                error ("cannot declare reference to %q#T, which is not "
+                       "a typedef or a template type argument", type);
 	    }
 	  else if (TREE_CODE (type) == METHOD_TYPE)
 	    type = build_ptrmemfunc_type (build_pointer_type (type));
@@ -7316,12 +7338,14 @@
 
 	  /* Process a list of type modifier keywords (such as
 	     const or volatile) that were given inside the `*' or `&'.  */
-
 	  if (declarator->u.pointer.qualifiers)
 	    {
-	      type
-		= cp_build_qualified_type (type,
-					   declarator->u.pointer.qualifiers);
+              type = cp_build_qualified_type_real
+                (type, declarator->u.pointer.qualifiers,
+                 tf_error | tf_warning,
+                 (declarator->kind == cdk_reference
+                  && declarator->declarator
+                  && declarator->declarator->kind == cdk_reference));
 	      type_quals = cp_type_quals (type);
 	    }
 	  ctype = NULL_TREE;
@@ -8482,6 +8506,7 @@
       result = -1;
     }
   else if (TREE_CODE (arg_type) == REFERENCE_TYPE
+           && !TYPE_REF_IS_RVALUE(arg_type)
 	   && TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)) == DECL_CONTEXT (d))
     {
       if (CP_TYPE_CONST_P (TREE_TYPE (arg_type)))
Index: cp/call.c
===================================================================
--- cp/call.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/call.c	(.../trunk/gcc)	(revision 38)
@@ -95,6 +95,10 @@
   /* If KIND is ck_ptr or ck_pmem, true to indicate that a conversion
      from a pointer-to-derived to pointer-to-base is being performed.  */ 
   BOOL_BITFIELD base_p : 1;
+  /* If KIND is ck_ref_bind, true when either an lvalue reference is
+     being bound to an lvalue expression or an rvalue reference is 
+     being bound to an rvalue expression. */
+  BOOL_BITFIELD valuedness_matches_p: 1;
   /* The type of the expression resulting from the conversion.  */
   tree type;
   union {
@@ -174,7 +178,7 @@
 static conversion *reference_binding (tree, tree, tree, int);
 static conversion *build_conv (conversion_kind, tree, conversion *);
 static bool is_subseq (conversion *, conversion *);
-static tree maybe_handle_ref_bind (conversion **);
+static conversion *maybe_handle_ref_bind (conversion **);
 static void maybe_handle_implicit_object (conversion **);
 static struct z_candidate *add_candidate 
         (struct z_candidate **, tree, tree, size_t, 
@@ -184,7 +188,7 @@
 static bool reference_related_p (tree, tree);
 static bool reference_compatible_p (tree, tree);
 static conversion *convert_class_to_reference (tree, tree, tree);
-static conversion *direct_reference_binding (tree, conversion *);
+static conversion *direct_reference_binding (tree, conversion *, bool);
 static bool promoted_arithmetic_type_p (tree);
 static conversion *conditional_conversion (tree, tree);
 static char *name_as_c_string (tree, tree, bool *);
@@ -868,12 +872,12 @@
    converted to T as in [over.match.ref].  */
 
 static conversion *
-convert_class_to_reference (tree t, tree s, tree expr)
+convert_class_to_reference (tree rt, tree s, tree expr)
 {
   tree conversions;
   tree arglist;
   conversion *conv;
-  tree reference_type;
+  tree t;
   struct z_candidate *candidates;
   struct z_candidate *cand;
   bool any_viable_p;
@@ -907,7 +911,7 @@
   arglist = build_int_cst (build_pointer_type (s), 0);
   arglist = build_tree_list (NULL_TREE, arglist);
 
-  reference_type = build_reference_type (t);
+  t = TREE_TYPE (rt);
 
   while (conversions)
     {
@@ -928,7 +932,7 @@
 					     f, s,
 					     NULL_TREE,
 					     arglist,
-					     reference_type,
+					     rt,
 					     TYPE_BINFO (s),
 					     TREE_PURPOSE (conversions),
 					     LOOKUP_NORMAL,
@@ -969,7 +973,10 @@
 				       NULL_TREE);
 	      cand->second_conv
 		= (direct_reference_binding 
-		   (reference_type, identity_conv));
+		   (rt, identity_conv, TYPE_REF_IS_RVALUE
+                                       (TREE_TYPE
+                                        (TREE_TYPE (cand->fn)))
+                                       == TYPE_REF_IS_RVALUE(rt)));
 	      cand->second_conv->bad_p |= cand->convs[0]->bad_p;
 	    }
 	}
@@ -1014,9 +1021,11 @@
    Return a conversion sequence for this binding.  */
 
 static conversion *
-direct_reference_binding (tree type, conversion *conv)
+direct_reference_binding (tree type, conversion *conv,
+                          bool valuedness_matches)
 {
   tree t;
+  conversion *c;
 
   gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);
   gcc_assert (TREE_CODE (conv->type) != REFERENCE_TYPE);
@@ -1048,7 +1057,9 @@
 	 That way, convert_like knows not to generate a temporary.  */
       conv->need_temporary_p = false;
     }
-  return build_conv (ck_ref_bind, type, conv);
+  c = build_conv (ck_ref_bind, type, conv);
+  c->valuedness_matches_p = valuedness_matches;
+  return c;
 }
 
 /* Returns the conversion path from type FROM to reference type TO for
@@ -1066,6 +1077,7 @@
   bool related_p;
   bool compatible_p;
   cp_lvalue_kind lvalue_p = clk_none;
+  bool rvalue_p = TYPE_REF_IS_RVALUE(rto);
 
   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))
     {
@@ -1102,7 +1114,7 @@
 	 the reference is bound directly to the initializer expression
 	 lvalue.  */
       conv = build_identity_conv (from, expr);
-      conv = direct_reference_binding (rto, conv);
+      conv = direct_reference_binding (rto, conv, !rvalue_p);
       if ((lvalue_p & clk_bitfield) != 0
 	  || ((lvalue_p & clk_packed) != 0 && !TYPE_PACKED (to)))
 	/* For the purposes of overload resolution, we ignore the fact
@@ -1135,7 +1147,7 @@
 
         the reference is bound to the lvalue result of the conversion
 	in the second case.  */
-      conv = convert_class_to_reference (to, from, expr);
+      conv = convert_class_to_reference (rto, from, expr);
       if (conv)
 	return conv;
     }
@@ -1159,7 +1171,7 @@
   /* [dcl.init.ref]
 
      Otherwise, the reference shall be to a non-volatile const type.  */
-  if (!CP_TYPE_CONST_NON_VOLATILE_P (to))
+  if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !rvalue_p)
     return NULL;
 
   /* [dcl.init.ref]
@@ -1181,7 +1193,7 @@
   if (CLASS_TYPE_P (from) && compatible_p)
     {
       conv = build_identity_conv (from, expr);
-      conv = direct_reference_binding (rto, conv);
+      conv = direct_reference_binding (rto, conv, rvalue_p);
       if (!(flags & LOOKUP_CONSTRUCTOR_CALLABLE))
 	conv->u.next->check_copy_constructor_p = true;
       return conv;
@@ -1205,6 +1217,7 @@
   /* This reference binding, unlike those above, requires the
      creation of a temporary.  */
   conv->need_temporary_p = true;
+  conv->valuedness_matches_p = rvalue_p;
 
   return conv;
 }
@@ -1244,7 +1257,7 @@
 	conv = cand->second_conv;
 
       /* We used to try to bind a reference to a temporary here, but that
-	 is now handled by the recursive call to this function at the end
+	 is now handled after the recursive call to this function at the end
 	 of reference_binding.  */
       return conv;
     }
@@ -4318,12 +4331,13 @@
 	tree ref_type = totype;
 
 	/* If necessary, create a temporary.  */
-	if (convs->need_temporary_p || !lvalue_p (expr))
+	if (convs->need_temporary_p)
 	  {
 	    tree type = convs->u.next->type;
 	    cp_lvalue_kind lvalue = real_lvalue_p (expr);
 
-	    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type)))
+	    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type))
+                && !TYPE_REF_IS_RVALUE(ref_type))
 	      {
 		/* If the reference is volatile or non-const, we
 		   cannot create a temporary.  */
@@ -5515,29 +5529,28 @@
       if (t->kind == ck_ptr)
 	t = t->u.next;
       t = build_identity_conv (TREE_TYPE (t->type), NULL_TREE);
-      t = direct_reference_binding (reference_type, t); 
+      t = direct_reference_binding (reference_type, t, 1); 
       *ics = t;
     }
 }
 
 /* If *ICS is a REF_BIND set *ICS to the remainder of the conversion,
-   and return the type to which the reference refers.  Otherwise,
-   leave *ICS unchanged and return NULL_TREE.  */
+   and return the initial reference binding conversion. Otherwise,
+   leave *ICS unchanged and return NULL.  */
 
-static tree
+static conversion *
 maybe_handle_ref_bind (conversion **ics)
 {
   if ((*ics)->kind == ck_ref_bind)
     {
       conversion *old_ics = *ics;
-      tree type = TREE_TYPE (old_ics->type);
       *ics = old_ics->u.next;
       (*ics)->user_conv_p = old_ics->user_conv_p;
       (*ics)->bad_p = old_ics->bad_p;
-      return type;
+      return old_ics;
     }
 
-  return NULL_TREE;
+  return NULL;
 }
 
 /* Compare two implicit conversion sequences according to the rules set out in
@@ -5561,18 +5574,18 @@
   conversion_rank rank1, rank2;
 
   /* REF_BINDING is nonzero if the result of the conversion sequence
-     is a reference type.   In that case TARGET_TYPE is the
-     type referred to by the reference.  */
-  tree target_type1;
-  tree target_type2;
+     is a reference type.   In that case REF_CONV is the 
+     reference binding conversion. */
+  conversion *ref_conv1;
+  conversion *ref_conv2;
 
   /* Handle implicit object parameters.  */
   maybe_handle_implicit_object (&ics1);
   maybe_handle_implicit_object (&ics2);
 
   /* Handle reference parameters.  */
-  target_type1 = maybe_handle_ref_bind (&ics1);
-  target_type2 = maybe_handle_ref_bind (&ics2);
+  ref_conv1 = maybe_handle_ref_bind (&ics1);
+  ref_conv2 = maybe_handle_ref_bind (&ics2);
 
   /* [over.ics.rank]
 
@@ -5869,10 +5882,35 @@
      initialized by S2 refers is more cv-qualified than the type to
      which the reference initialized by S1 refers */
       
-  if (target_type1 && target_type2
+  /* Before checking the reference types' cv-qualifiers, check for
+     matching lvalue/rvalue references and arguments as proposed
+     in N1377.
+
+       rvalues will prefer rvalue references. lvalues will prefer
+       lvalue references. CV qualification conversions are
+       considered secondary relative to r/l-value conversions. 
+       rvalues can still bind to a const lvalue reference
+       (const A&), but only if there is not a more attractive
+       rvalue reference in the overload set. lvalues can bind to an
+       rvalue reference, but will prefer an lvalue reference if it
+       exists in the overload set. The rule that a more cv-qualified
+       object can not bind to a less cv-qualified reference stands 
+       ... both for lvalue and rvalue references. */
+
+  if (ref_conv1 && ref_conv2
       && same_type_ignoring_top_level_qualifiers_p (to_type1, to_type2))
-    return comp_cv_qualification (target_type2, target_type1);
+    {
+      if (ref_conv1->valuedness_matches_p 
+          && !ref_conv2->valuedness_matches_p)
+        return 1;
+      else if (!ref_conv1->valuedness_matches_p 
+          && ref_conv2->valuedness_matches_p)
+        return -1;
 
+      return comp_cv_qualification (TREE_TYPE (ref_conv2->type),
+                                    TREE_TYPE (ref_conv1->type));
+    }
+
   /* Neither conversion sequence is better than the other.  */
   return 0;
 }
Index: cp/error.c
===================================================================
--- cp/error.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/error.c	(.../trunk/gcc)	(revision 38)
@@ -503,7 +503,13 @@
 	    pp_cxx_whitespace (cxx_pp);
 	    pp_cxx_left_paren (cxx_pp);
 	  }
-	pp_character (cxx_pp, "&*"[TREE_CODE (t) == POINTER_TYPE]);
+        if (TREE_CODE (t) == POINTER_TYPE)
+          pp_character(cxx_pp, '*');
+        else if (TREE_CODE (t) == REFERENCE_TYPE)
+          if (TYPE_REF_IS_RVALUE (t))
+            pp_string (cxx_pp, "&&");
+          else
+            pp_character (cxx_pp, '&');
         pp_base (cxx_pp)->padding = pp_before;
         pp_cxx_cv_qualifier_seq (cxx_pp, t);
       }
Index: cp/tree.c
===================================================================
--- cp/tree.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/tree.c	(.../trunk/gcc)	(revision 38)
@@ -63,9 +63,28 @@
   cp_lvalue_kind op1_lvalue_kind = clk_none;
   cp_lvalue_kind op2_lvalue_kind = clk_none;
 
+  /* Expressions of reference type are sometimes wrapped in
+     INDIRECT_REFs */
+  /* XXX: REFERENCE_REF_P may be a better way to check */
+  if (TREE_CODE (ref) == INDIRECT_REF
+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0)))
+         == REFERENCE_TYPE)
+    return lvalue_p_1(TREE_OPERAND (ref, 0),
+                      treat_class_rvalues_as_lvalues);
+
   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)
-    return clk_ordinary;
+    {
+       /* unnamed rvalue references are rvalues */
+       if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref))
+           && TREE_CODE (ref) != PARM_DECL
+           && TREE_CODE (ref) != VAR_DECL
+           && TREE_CODE (ref) != COMPONENT_REF)
+         return clk_none;
 
+       /* lvalue references and named rvalue refences are lvalues */
+       return clk_ordinary;
+     }
+
   if (ref == current_class_ptr)
     return clk_none;
 
@@ -434,7 +453,8 @@
 tree
 cp_build_qualified_type_real (tree type,
                               int type_quals,
-                              tsubst_flags_t complain)
+                              tsubst_flags_t complain,
+                              bool fold_ref)
 {
   tree result;
   int bad_quals = TYPE_UNQUALIFIED;
@@ -453,7 +473,7 @@
       tree element_type
 	= cp_build_qualified_type_real (TREE_TYPE (type),
 					type_quals,
-					complain);
+					complain, 0);
 
       if (element_type == error_mark_node)
 	return error_mark_node;
@@ -495,15 +515,13 @@
       tree t;
 
       t = TYPE_PTRMEMFUNC_FN_TYPE (type);
-      t = cp_build_qualified_type_real (t, type_quals, complain);
+      t = cp_build_qualified_type_real (t, type_quals, complain, 0);
       return build_ptrmemfunc_type (t);
     }
 
-  /* A reference or method type shall not be cv qualified.
-     [dcl.ref], [dct.fct]  */
+  /* A method type shall not be cv qualified [dct.fct]  */
   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)
-      && (TREE_CODE (type) == REFERENCE_TYPE
-	  || TREE_CODE (type) == METHOD_TYPE))
+      && TREE_CODE (type) == METHOD_TYPE)
     {
       bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);
       type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);
@@ -541,6 +559,61 @@
  	}
     }
 
+  /* C++ doesn't have a consistent way of handling cv-qualifiers on
+     reference types. They are not allowed in normal type expressions,
+     for example:
+
+       void f(int & const); // error: const qualifier cannot be applied
+
+     But there is an exception to allow them, and ignore them for
+     references which are typedefs or template parameters.
+
+       typedef int & int_ref;
+       void f(int_ref const); // legal, treated like f(int &)
+
+     The proposed "reference collapsing" solution to CWG Defect 106
+     creates an exception to the exception for references which are part
+     of reference to reference declarations. There, a reference type that
+     is cv-qualified and followed by an extra reference declarator has its
+     cv-qualifiers applied to the type it refers to, instead of ignored.
+
+       void f(int_ref const &); // treated like f(int const &)
+
+     The COMPLAIN and FOLD_REF arguments determine which way to handle the
+     qualifiers, if any are present. If FOLD_REF is true, cv-qualifiers
+     on the reference are applied to the type the reference refers to.
+     Otherwise, if the tf_ignore_bad_quals flag in COMPLAIN is set, the
+     qualifiers are ignored, and otherwise an error is emitted.
+   */
+  if (TREE_CODE (type) == REFERENCE_TYPE)
+    {
+      int cv_quals = type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);
+
+      if (cv_quals)
+        {
+          /* fold in cv-qualifiers */
+          if (fold_ref)
+            type = build_rval_reference_type_for_mode
+            (cp_build_qualified_type_real
+             (TREE_TYPE (type), cv_quals | cp_type_quals (TREE_TYPE (type)),
+              complain, 0),
+             TYPE_MODE (type),
+             TYPE_REF_CAN_ALIAS_ALL (type),
+             TYPE_REF_IS_RVALUE(type));
+
+          /* emit error */
+          else if (!(complain & tf_ignore_bad_quals))
+            {
+              tree bad_type = build_qualified_type (ptr_type_node,
+                                                    type_quals);
+ 	      error ("%qV qualifiers cannot be applied to reference type "
+                     "%qT in this context", bad_type, type);
+            }
+        }
+       /* drop cv-qualifiers */
+       type_quals &= ~cv_quals;
+    }
+
   /* Retrieve (or create) the appropriately qualified variant.  */
   result = build_qualified_type (type, type_quals);
 
Index: cp/mangle.c
===================================================================
--- cp/mangle.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/mangle.c	(.../trunk/gcc)	(revision 38)
@@ -1618,7 +1618,17 @@
 	  break;
 
 	case REFERENCE_TYPE:
-	  write_char ('R');
+          /* XXX: Writing 'B' for rrvalue references is an interim 
+             solution, chosen because a grep for "'B'" in this file
+             came up empty. Need to come back to this, read the ABI
+             spec, see if there's a better letter available, see
+             if this is this is a legitimate way of mangling, and
+             see if there aren't other parts of the code that need
+             to be modified. */ 
+          if TYPE_REF_IS_RVALUE(type)
+            write_char('B');
+          else
+	    write_char ('R');
 	  write_type (TREE_TYPE (type));
 	  break;
 
Index: cp/cp-tree.h
===================================================================
--- cp/cp-tree.h	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/cp-tree.h	(.../trunk/gcc)	(revision 38)
@@ -3633,6 +3633,7 @@
       cp_cv_quals qualifiers;
       /* For cdk_ptrmem, the class type containing the member.  */
       tree class_type;
+      bool rvalue_ref;
     } pointer;
   } u;
 };
@@ -4249,9 +4250,10 @@
 extern const struct attribute_spec cxx_attribute_table[];
 extern tree make_ptrmem_cst                     (tree, tree);
 extern tree cp_build_type_attribute_variant     (tree, tree);
-extern tree cp_build_qualified_type_real        (tree, int, tsubst_flags_t);
+extern tree cp_build_qualified_type_real        (tree, int, tsubst_flags_t,
+                                                 bool);
 #define cp_build_qualified_type(TYPE, QUALS) \
-  cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning)
+  cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning, 0)
 extern special_function_kind special_function_p (tree);
 extern int count_trees                          (tree);
 extern int char_type_p                          (tree);
Index: cp/pt.c
===================================================================
--- cp/pt.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/pt.c	(.../trunk/gcc)	(revision 38)
@@ -94,7 +94,7 @@
 					   unification_kind_t, int);
 static int try_one_overload (tree, tree, tree, tree, tree,
 			     unification_kind_t, int, bool);
-static int unify (tree, tree, tree, tree, int);
+static int unify (tree, tree, tree, tree, int, bool);
 static void add_pending_template (tree);
 static void reopen_tinst_level (tree);
 static tree classtype_mangled_name (tree);
@@ -161,6 +161,7 @@
 static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);
 static int eq_local_specializations (const void *, const void *);
 static bool dependent_type_p_r (tree);
+static tree tsubst_1 (tree, tree, tsubst_flags_t, tree, bool);
 static tree tsubst (tree, tree, tsubst_flags_t, tree);
 static tree tsubst_expr	(tree, tree, tsubst_flags_t, tree);
 static tree tsubst_copy	(tree, tree, tsubst_flags_t, tree);
@@ -6033,7 +6034,7 @@
   	  r = lookup_template_class (t, argvec, in_decl, context,
 				     entering_scope, complain);
 
-	  return cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);
+	  return cp_build_qualified_type_real (r, TYPE_QUALS (t), complain, 0);
 	}
       else 
 	/* This is not a template type, so there's nothing to do.  */
@@ -6791,7 +6792,7 @@
       fntype = build_method_type_directly (r, return_type, 
 					   TREE_CHAIN (arg_types));
     }
-  fntype = cp_build_qualified_type_real (fntype, TYPE_QUALS (t), complain);
+  fntype = cp_build_qualified_type_real (fntype, TYPE_QUALS (t), complain, 0);
   fntype = cp_build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));
   
   return fntype;  
@@ -6880,7 +6881,8 @@
    for expressions, use tsubst_expr or tsubst_copy.  */
 
 static tree
-tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+tsubst_1 (tree t, tree args, tsubst_flags_t complain, tree in_decl,
+          bool fold_ref)
 {
   tree type, r;
 
@@ -6907,7 +6909,8 @@
       && TREE_CODE (t) != IDENTIFIER_NODE
       && TREE_CODE (t) != FUNCTION_TYPE
       && TREE_CODE (t) != METHOD_TYPE)
-    type = tsubst (type, args, complain, in_decl);
+    type = tsubst_1 (type, args, complain, in_decl,
+                   TREE_CODE (t) == REFERENCE_TYPE);
   if (type == error_mark_node)
     return error_mark_node;
 
@@ -7012,7 +7015,7 @@
 		gcc_assert (TYPE_P (arg));
 		return cp_build_qualified_type_real
 		  (arg, cp_type_quals (arg) | cp_type_quals (t),
-		   complain | tf_ignore_bad_quals);
+		   complain | tf_ignore_bad_quals, fold_ref);
 	      }
 	    else if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)
 	      {
@@ -7037,7 +7040,7 @@
 					    /*entering_scope=*/0,
 					   complain);
 		return cp_build_qualified_type_real
-		  (r, TYPE_QUALS (t), complain);
+		  (r, TYPE_QUALS (t), complain, fold_ref);
 	      }
 	    else
 	      /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */
@@ -7060,11 +7063,13 @@
 	  case BOUND_TEMPLATE_TEMPLATE_PARM:
 	    if (cp_type_quals (t))
 	      {
-		r = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);
+		r = tsubst_1 (TYPE_MAIN_VARIANT (t), args, complain, 
+                              in_decl, fold_ref);
  		r = cp_build_qualified_type_real
  		  (r, cp_type_quals (t),
 		   complain | (TREE_CODE (t) == TEMPLATE_TYPE_PARM
-			       ? tf_ignore_bad_quals : 0));
+			       ? tf_ignore_bad_quals : 0),
+                   fold_ref);
 	      }
 	    else
 	      {
@@ -7163,8 +7168,12 @@
 
 	   -- Attempting to create a pointer to reference type.
 	   -- Attempting to create a reference to a reference type or
-	      a reference to void.  */
-	if (TREE_CODE (type) == REFERENCE_TYPE
+	      a reference to void
+
+           However, references to references are allowed in the proposed
+           resolution to DR 106.  */
+
+	if ((code == POINTER_TYPE && TREE_CODE (type) == REFERENCE_TYPE)
 	    || (code == REFERENCE_TYPE && TREE_CODE (type) == VOID_TYPE))
 	  {
 	    static location_t last_loc;
@@ -7198,10 +7207,17 @@
 	    if (TREE_CODE (type) == METHOD_TYPE)
 	      r = build_ptrmemfunc_type (r);
 	  }
-	else
-	  r = build_reference_type (type);
-	r = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);
+        else if (TREE_CODE (type) == REFERENCE_TYPE)
+          /* collapse reference */
+          r = build_rval_reference_type
+              (TREE_TYPE (type),
+               TYPE_REF_IS_RVALUE (t) && TYPE_REF_IS_RVALUE (type));
+        else
+          r = build_rval_reference_type (type, TYPE_REF_IS_RVALUE (t));
 
+        r = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain,
+                                          fold_ref);
+
 	if (r != error_mark_node)
 	  /* Will this ever be needed for TYPE_..._TO values?  */
 	  layout_type (r);
@@ -7245,12 +7261,12 @@
 						      TYPE_ARG_TYPES (type));
             memptr = build_ptrmemfunc_type (build_pointer_type (method_type));
             return cp_build_qualified_type_real (memptr, cp_type_quals (t),
-                                                 complain);
+                                                 complain, fold_ref);
 	  }
 	else
 	  return cp_build_qualified_type_real (build_ptrmem_type (r, type),
 					       TYPE_QUALS (t),
-					       complain);
+					       complain, fold_ref);
       }
     case FUNCTION_TYPE:
     case METHOD_TYPE:
@@ -7386,7 +7402,7 @@
 	  }
 
  	return cp_build_qualified_type_real
- 	  (f, cp_type_quals (f) | cp_type_quals (t), complain);
+ 	  (f, cp_type_quals (f) | cp_type_quals (t), complain, fold_ref);
       }
 	       
     case UNBOUND_CLASS_TEMPLATE:
@@ -7438,7 +7454,7 @@
 	return cp_build_qualified_type_real (type,
 					     cp_type_quals (t)
 					     | cp_type_quals (type),
-					     complain);
+					     complain, fold_ref);
       }
 
     default:
@@ -7448,6 +7464,14 @@
     }
 }
 
+/* Call tsubst_1 with default value for fold_ref argument */
+
+static tree
+tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+{
+  return tsubst_1 (t, args, complain, in_decl, 0);
+}
+
 /* Like tsubst_expr for a BASELINK.  OBJECT_TYPE, if non-NULL, is the
    type of the expression on the left-hand side of the "." or "->"
    operator.  */
@@ -9281,6 +9305,7 @@
                        int xlen)
 {
   tree parm, arg;
+  bool deduce_ref;
   int i;
   int ntparms = TREE_VEC_LENGTH (tparms);
   int sub_strict;
@@ -9334,6 +9359,14 @@
       arg = TREE_VALUE (args);
       args = TREE_CHAIN (args);
 
+      /* As proposed in N1770, if PARM is an rvalue-reference type of
+         the form cv T&& where T is a template type-parameter, and the
+         argument is an lvalue, the deduced template argument value for
+         T is ARG&.  */
+      deduce_ref = (TREE_CODE (parm) == REFERENCE_TYPE
+                    && TYPE_REF_IS_RVALUE (parm)
+                    && real_lvalue_p (arg));
+
       if (arg == error_mark_node)
 	return 1;
       if (arg == unknown_type_node)
@@ -9396,7 +9429,7 @@
         if (!subr)
 	  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);
 
-        if (unify (tparms, targs, parm, arg, arg_strict))
+        if (unify (tparms, targs, parm, arg, arg_strict, deduce_ref))
           return 1;
       }
 
@@ -9579,7 +9612,7 @@
   nargs = TREE_VEC_LENGTH (targs);
   tempargs = make_tree_vec (nargs);
 
-  if (unify (tparms, tempargs, parm, arg, sub_strict) != 0)
+  if (unify (tparms, tempargs, parm, arg, sub_strict, false) != 0)
     return 0;
 
   /* First make sure we didn't deduce anything that conflicts with
@@ -9691,7 +9724,7 @@
   
   /* If unification failed, we're done.  */
   if (unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),
-	     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE))
+	     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE, false))
     return NULL_TREE;
 
   return arg;
@@ -9834,10 +9867,14 @@
        qualified at this point.
      UNIFY_ALLOW_OUTER_LESS_CV_QUAL:
        This is the outermost level of a deduction, and PARM can be less CV
-       qualified at this point.  */
+       qualified at this point.
 
+   The DEDUCE_REF parameter is true if a template type parameter should be
+   deduced as a reference.  */
+
 static int
-unify (tree tparms, tree targs, tree parm, tree arg, int strict)
+unify (tree tparms, tree targs, tree parm, tree arg, int strict,
+       bool deduce_ref)
 {
   int idx;
   tree targ;
@@ -9958,7 +9995,7 @@
 	        if (unify (tparms, targs, 
 			   TREE_VEC_ELT (parmvec, i), 
 			   TREE_VEC_ELT (argvec, i), 
-			   UNIFY_ALLOW_NONE))
+			   UNIFY_ALLOW_NONE, false))
 		  return 1;
 	      }
 	  }
@@ -9991,10 +10028,13 @@
 	  /* Consider the case where ARG is `const volatile int' and
 	     PARM is `const T'.  Then, T should be `volatile int'.  */
 	  arg = cp_build_qualified_type_real
-	    (arg, cp_type_quals (arg) & ~cp_type_quals (parm), tf_none);
+	    (arg, cp_type_quals (arg) & ~cp_type_quals (parm), tf_none, 0);
 	  if (arg == error_mark_node)
 	    return 1;
 
+         if (deduce_ref && TREE_CODE (parm) == TEMPLATE_TYPE_PARM)
+            arg = build_reference_type (arg);
+
 	  /* Simple cases: Value already set, does match or doesn't.  */
 	  if (targ != NULL_TREE && same_type_p (targ, arg))
 	    return 0;
@@ -10081,7 +10121,7 @@
 
          Unification of &A::x and &B::x must succeed.  */
       return unify (tparms, targs, PTRMEM_CST_MEMBER (parm),
-                    PTRMEM_CST_MEMBER (arg), strict);
+                    PTRMEM_CST_MEMBER (arg), strict, false);
      }
 
     case POINTER_TYPE:
@@ -10105,14 +10145,14 @@
 	  strict |= (strict_in & UNIFY_ALLOW_DERIVED);
 
 	return unify (tparms, targs, TREE_TYPE (parm), 
-		      TREE_TYPE (arg), strict);
+		      TREE_TYPE (arg), strict, false);
       }
 
     case REFERENCE_TYPE:
       if (TREE_CODE (arg) != REFERENCE_TYPE)
 	return 1;
       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),
-		    strict & UNIFY_ALLOW_MORE_CV_QUAL);
+		    strict & UNIFY_ALLOW_MORE_CV_QUAL, false);
 
     case ARRAY_TYPE:
       if (TREE_CODE (arg) != ARRAY_TYPE)
@@ -10140,11 +10180,12 @@
 	      parm_max = TREE_OPERAND (parm_max, 0);
 	    }
 
-	  if (unify (tparms, targs, parm_max, arg_max, UNIFY_ALLOW_INTEGER))
+	  if (unify (tparms, targs, parm_max, arg_max, UNIFY_ALLOW_INTEGER,
+                     false))
 	    return 1;
 	}
       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),
-		    strict & UNIFY_ALLOW_MORE_CV_QUAL);
+		    strict & UNIFY_ALLOW_MORE_CV_QUAL, false);
 
     case REAL_TYPE:
     case COMPLEX_TYPE:
@@ -10185,7 +10226,7 @@
 	for (i = 0; i < TREE_VEC_LENGTH (parm); ++i)
 	  if (unify (tparms, targs,
 		     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),
-		     UNIFY_ALLOW_NONE))
+		     UNIFY_ALLOW_NONE, false))
 	    return 1;
 	return 0;
       }
@@ -10203,7 +10244,7 @@
 	  return unify (tparms, targs, 
 			TYPE_PTRMEMFUNC_FN_TYPE (parm),
 			TYPE_PTRMEMFUNC_FN_TYPE (arg),
-			strict);
+			strict, false);
 	}
 
       if (CLASSTYPE_TEMPLATE_INFO (parm))
@@ -10244,7 +10285,7 @@
 	    return 1;
 
 	  return unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),
-			CLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE);
+			CLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE, false);
 	}
       else if (!same_type_ignoring_top_level_qualifiers_p (parm, arg))
 	return 1;
@@ -10256,7 +10297,7 @@
 	return 1;
 
       if (unify (tparms, targs, TREE_TYPE (parm),
-		 TREE_TYPE (arg), UNIFY_ALLOW_NONE))
+		 TREE_TYPE (arg), UNIFY_ALLOW_NONE, false))
 	return 1;
       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),
 				    TYPE_ARG_TYPES (arg), 1, 
@@ -10276,7 +10317,8 @@
             return 1;
 
           if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),
-                     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE))
+                     TYPE_PTRMEMFUNC_OBJECT_TYPE (arg), UNIFY_ALLOW_NONE,
+                     false))
             return 1;
 
           /* Determine the type of the function we are unifying against. */
@@ -10291,20 +10333,22 @@
           cv_quals = 
             cp_type_quals(TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (method_type))));
           fntype = build_qualified_type (fntype, cv_quals);
-          return unify (tparms, targs, TREE_TYPE (parm), fntype, strict);
+          return unify (tparms, targs, TREE_TYPE (parm), fntype, strict,
+                        false);
         }
 
       if (TREE_CODE (arg) != OFFSET_TYPE)
 	return 1;
       if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),
-		 TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE))
+		 TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE, false))
 	return 1;
       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),
-		    strict);
+		    strict, false);
 
     case CONST_DECL:
       if (DECL_TEMPLATE_PARM_P (parm))
-	return unify (tparms, targs, DECL_INITIAL (parm), arg, strict);
+	return unify (tparms, targs, DECL_INITIAL (parm), arg, strict,
+                      false);
       if (arg != integral_constant_value (parm)) 
 	return 1;
       return 0;
@@ -10570,7 +10614,7 @@
   tree vec = make_tree_vec (ntparms);
 
   if (unify (tparms, vec, parms, INNERMOST_TEMPLATE_ARGS (args),
-  	     UNIFY_ALLOW_NONE))
+  	     UNIFY_ALLOW_NONE, false))
     return NULL_TREE;
 
   for (i =  0; i < ntparms; ++i)
Index: cp/parser.c
===================================================================
--- cp/parser.c	(.../vendor/gcc/4.0.0/gcc)	(revision 38)
+++ cp/parser.c	(.../trunk/gcc)	(revision 38)
@@ -758,7 +758,7 @@
 static cp_declarator *make_pointer_declarator
   (cp_cv_quals, cp_declarator *);
 static cp_declarator *make_reference_declarator
-  (cp_cv_quals, cp_declarator *);
+  (cp_cv_quals, cp_declarator *, bool);
 static cp_parameter_declarator *make_parameter_declarator
   (cp_decl_specifier_seq *, cp_declarator *, tree);
 static cp_declarator *make_ptrmem_declarator
@@ -844,7 +844,8 @@
 /* Like make_pointer_declarator -- but for references.  */
 
 cp_declarator *
-make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)
+make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,
+                           bool rvalue_ref)
 {
   cp_declarator *declarator;
 
@@ -852,6 +853,7 @@
   declarator->declarator = target;
   declarator->u.pointer.qualifiers = cv_qualifiers;
   declarator->u.pointer.class_type = NULL_TREE;
+  declarator->u.pointer.rvalue_ref = rvalue_ref;
 
   return declarator;
 }
@@ -1762,6 +1764,8 @@
   (cp_token *, enum rid);
 static tree cp_parser_make_typename_type
   (cp_parser *, tree, tree);
+static cp_declarator * cp_parser_make_indirect_declarator
+  (enum tree_code, tree, cp_cv_quals, cp_declarator *);
 
 /* Returns nonzero if we are parsing tentatively.  */
 
@@ -2344,6 +2348,27 @@
   return make_typename_type (scope, id, typename_type, tf_error);
 }
 
+/* This is a wrapper around the
+   make_{pointer,ptrmem,reference}_declarator functions that decides
+   which one to call based on the CODE and CLASS_TYPE arguments. The
+   CODE argument should be one of the values returned by
+   cp_parser_ptr_operator. */
+static cp_declarator *
+cp_parser_make_indirect_declarator (enum tree_code code, tree class_type,
+                                    cp_cv_quals cv_qualifiers,
+                                    cp_declarator *target)
+{
+  if (code == INDIRECT_REF)
+    if (class_type == NULL_TREE)
+      return make_pointer_declarator (cv_qualifiers, target);
+    else
+      return make_ptrmem_declarator (cv_qualifiers, class_type, target);
+  else if (code == ADDR_EXPR && class_type == NULL_TREE)
+    return make_reference_declarator (cv_qualifiers, target, false);
+  else if (code == NON_LVALUE_EXPR && class_type == NULL_TREE)
+    return make_reference_declarator (cv_qualifiers, target, true);
+  gcc_unreachable ();
+}
 
 /* Create a new C++ parser.  */
 
@@ -5049,15 +5074,8 @@
       /* Parse another optional declarator.  */
       declarator = cp_parser_new_declarator_opt (parser);
 
-      /* Create the representation of the declarator.  */
-      if (type)
-	declarator = make_ptrmem_declarator (cv_quals, type, declarator);
-      else if (code == INDIRECT_REF)
-	declarator = make_pointer_declarator (cv_quals, declarator);
-      else
-	declarator = make_reference_declarator (cv_quals, declarator);
-
-      return declarator;
+      return cp_parser_make_indirect_declarator
+               (code, type, cv_quals, declarator);
     }
 
   /* If the next token is a `[', there is a direct-new-declarator.  */
@@ -7607,18 +7625,10 @@
       /* Parse another optional declarator.  */
       declarator = cp_parser_conversion_declarator_opt (parser);
 
-      /* Create the representation of the declarator.  */
-      if (class_type)
-	declarator = make_ptrmem_declarator (cv_quals, class_type,
-					     declarator);
-      else if (code == INDIRECT_REF)
-	declarator = make_pointer_declarator (cv_quals, declarator);
-      else
-	declarator = make_reference_declarator (cv_quals, declarator);
+      return cp_parser_make_indirect_declarator
+               (code, class_type, cv_quals, declarator);
+    }
 
-      return declarator;
-   }
-
   return NULL;
 }
 
@@ -10893,15 +10903,8 @@
 	  && !cp_parser_parse_definitely (parser))
 	declarator = NULL;
 
-      /* Build the representation of the ptr-operator.  */
-      if (class_type)
-	declarator = make_ptrmem_declarator (cv_quals,
-					     class_type,
-					     declarator);
-      else if (code == INDIRECT_REF)
-	declarator = make_pointer_declarator (cv_quals, declarator);
-      else
-	declarator = make_reference_declarator (cv_quals, declarator);
+      declarator = cp_parser_make_indirect_declarator
+                     (code, class_type, cv_quals, declarator);
     }
   /* Everything else is a direct-declarator.  */
   else
@@ -11312,12 +11315,15 @@
      & cv-qualifier-seq [opt]
 
    Returns INDIRECT_REF if a pointer, or pointer-to-member, was used.
-   Returns ADDR_EXPR if a reference was used.  In the case of a
-   pointer-to-member, *TYPE is filled in with the TYPE containing the
-   member.  *CV_QUALS is filled in with the cv-qualifier-seq, or
-   TYPE_UNQUALIFIED, if there are no cv-qualifiers.  Returns
-   ERROR_MARK if an error occurred.  */
-
+   Returns ADDR_EXPR if a reference was used, or NON_LVALUE_EXPR for
+   an rvalue reference. In the case of a pointer-to-member, *TYPE is
+   filled in with the TYPE containing the member.  *CV_QUALS is
+   filled in with the cv-qualifier-seq, or TYPE_UNQUALIFIED, if there
+   are no cv-qualifiers.  Returns ERROR_MARK if an error occurred.
+   Note that the tree codes returned by this function have nothing
+   to do with the types of trees that will be eventually be created
+   to represent the pointer or reference type being parsed. They are
+   just constants with suggestive names. */
 static enum tree_code
 cp_parser_ptr_operator (cp_parser* parser,
                         tree* type,
@@ -11333,13 +11339,18 @@
 
   /* Peek at the next token.  */
   token = cp_lexer_peek_token (parser->lexer);
-  /* If it's a `*' or `&' we have a pointer or reference.  */
-  if (token->type == CPP_MULT || token->type == CPP_AND)
+
+  /* If it's a `*', `&' or `&&' we have a pointer or reference.  */
+  if (token->type == CPP_MULT)
+    code = INDIRECT_REF;
+  else if (token->type == CPP_AND)
+    code = ADDR_EXPR;
+  else if (token->type == CPP_AND_AND)
+    code = NON_LVALUE_EXPR;
+
+  if (code != ERROR_MARK)
     {
-      /* Remember which ptr-operator we were processing.  */
-      code = (token->type == CPP_AND ? ADDR_EXPR : INDIRECT_REF);
-
-      /* Consume the `*' or `&'.  */
+      /* Consume the `*', `&' or `&&'.  */
       cp_lexer_consume_token (parser->lexer);
 
       /* A `*' can be followed by a cv-qualifier-seq, and so can a
